# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Joe Nelson, Steve Chavez
# This file is distributed under the same license as the PostgREST package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: PostgREST 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-10 19:43+0800\n"
"PO-Revision-Date: 2022-01-17 21:06+0800\n"
"Last-Translator: YCH <chnyyk@gmail.com>\n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../schema_structure.rst:4
msgid "This page is a work in progress."
msgstr "本页内容尚在完善中。"

#: ../../schema_structure.rst:9
msgid "Schema Isolation"
msgstr "Schema 隔离"

#: ../../schema_structure.rst:11
msgid ""
"A PostgREST instance exposes all the tables, views, and stored "
"procedures of a single `PostgreSQL schema <https://www.postgresql.org/"
"docs/current/ddl-schemas.html>`_ (a namespace of database objects). This "
"means private data or implementation details can go inside different "
"private schemas and be invisible to HTTP clients."
msgstr ""
"一个 PostgREST 实例暴露了一个单一的 `PostgreSQL Schema（数据库对象的命名"
"空间） <https://www.postgresql.org/docs/current/ddl-schemas.html>`_ 的所"
"有表、视图和存储过程。这意味着私有数据或实现细节可以进入不同的私有 "
"Schema，并且对 HTTP 客户端是不可见的。"

#: ../../schema_structure.rst:13
msgid ""
"It is recommended that you don't expose tables on your API schema. "
"Instead expose views and stored procedures which insulate the internal "
"details from the outside world. This allows you to change the internals "
"of your schema and maintain backwards compatibility. It also keeps your "
"code easier to refactor, and provides a natural way to do API versioning."
msgstr ""
"建议你不要在你的 API Schema 上暴露（实体）表。取而代之的是，暴露视图和存"
"储过程，将内部细节与外部世界隔离开来。这允许你改变 Schema 内部结构，并保"
"持向后兼容。它还可以使你的代码易于重构，并提供一种自然的方式进行 API 版本"
"控制。"

#: ../../schema_structure.rst:21
msgid "Functions"
msgstr "函数"

#: ../../schema_structure.rst:23
msgid ""
"By default, when a function is created, the privilege to execute it is "
"not restricted by role. The function access is ``PUBLIC`` — executable "
"by all roles (more details at `PostgreSQL Privileges page <https://www."
"postgresql.org/docs/current/ddl-priv.html>`_). This is not ideal for an "
"API schema. To disable this behavior, you can run the following SQL "
"statement:"
msgstr ""
"默认情况下，函数被创建后，执行它的权限不受角色限制。函数的访问权限是 "
"``PUBLIC`` —— 可由所有角色执行（详见 `PostgreSQL 权限页面 <https://www."
"postgresql.org/docs/current/ddl-priv.html>`_）。这对一个 API Schema 来说"
"并不理想。要禁用此行为，可以执行以下 SQL 语句："

#: ../../schema_structure.rst:29
msgid ""
"This will change the privileges for all functions created in the future "
"in all schemas. Currently there is no way to limit it to a single "
"schema. In our opinion it's a good practice anyway."
msgstr ""
"这将改变经后在所有 Schema 中创建的所有函数的权限。目前还没有办法将其限制"
"在某个单独的 Schema 中。在我们看来，无论如何这都是一个很好的实践。"

#: ../../schema_structure.rst:33
msgid ""
"It is however possible to limit the effect of this clause only to "
"functions you define. You can put the above statement at the beginning "
"of the API schema definition, and then at the end reverse it with:"
msgstr ""
"不过，可以将此子句的作用限制在你定义的函数中。你可以把上面的语句放在 API "
"Schema 定义的开头，然后在结束时将其还原："

#: ../../schema_structure.rst:39
msgid ""
"This will work because the :code:`alter default privileges` statement "
"has effect on function created *after* it is executed. See `PostgreSQL "
"alter default privileges <https://www.postgresql.org/docs/current/sql-"
"alterdefaultprivileges.html>`_ for more details."
msgstr ""
"这能起作用是因为 :code:`alter default privileges` 语句仅影响在其执行 **后"
"** 创建的函数。参见 `PostgreSQL 改变默认权限 <https://www.postgresql.org/"
"docs/current/sql-alterdefaultprivileges.html>`_。"

#: ../../schema_structure.rst:41
msgid ""
"After that, you'll need to grant EXECUTE privileges on functions "
"explicitly:"
msgstr "之后，你需要显式地授予函数 EXECUTE 权限："

#: ../../schema_structure.rst:48
msgid ""
"You can also grant execute on all functions in a schema to a higher "
"privileged role:"
msgstr "你也可以将 Schema 中所有函数的 EXECUTE 授予更高权限的角色："

#: ../../schema_structure.rst:55
msgid "Security definer"
msgstr "安全定义者（Security Definer）"

#: ../../schema_structure.rst:57
msgid ""
"A function is executed with the privileges of the user who calls it. "
"This means that the user has to have all permissions to do the "
"operations the procedure performs. If the function accesses private "
"database objects, your :ref:`API roles <roles>` won't be able to "
"successfully execute the function."
msgstr ""
"一个函数是以调用它的用户的权限来执行的。这意味着该用户必须有所有的权限来"
"完成该函数所执行的操作。如果该函数访问私有数据库对象，你的 :ref:`API 角"
"色 <roles>` 将不能成功执行该函数。"

#: ../../schema_structure.rst:60
msgid ""
"Another option is to define the function with the :code:`SECURITY "
"DEFINER` option. Then only one permission check will take place, the "
"permission to call the function, and the operations in the function will "
"have the authority of the user who owns the function itself."
msgstr ""
"另一个选项是带着 :code:`SECURITY DEFINER` 选项定义函数。然后，只会进行一"
"次权限检查，即调用函数的权限，函数中的操作将具有该函数本身的拥有者的权"
"限。"

#: ../../schema_structure.rst:76
msgid ""
"Note the ``SECURITY DEFINER`` keywords at the end of the function. See "
"`PostgreSQL documentation <https://www.postgresql.org/docs/current/sql-"
"createfunction.html#SQL-CREATEFUNCTION-SECURITY>`_ for more details."
msgstr ""
"请注意：``SECURITY DEFINER`` 关键词位于函数定义的最末尾。参见 "
"`PostgreSQL 创建函数 <https://www.postgresql.org/docs/current/sql-"
"createfunction.html#SQL-CREATEFUNCTION-SECURITY>`_ 以了解更多细节。"

#: ../../schema_structure.rst:79
msgid "Views"
msgstr "视图"

#: ../../schema_structure.rst:81
msgid ""
"Views are invoked with the privileges of the view owner, much like "
"stored procedures with the ``SECURITY DEFINER`` option. When created by "
"a SUPERUSER role, all `row-level security <https://www.postgresql.org/"
"docs/current/ddl-rowsecurity.html>`_ will be bypassed unless a "
"different, non-SUPERUSER owner is specified."
msgstr ""
"视图是以视图所有者的权限来调用的，就像使用了 ``SECURITY DEFINER`` 选项的"
"函数（存储过程）。当由超级用户（SUPERUSER）角色创建时，所有的 `行安全性"
"（Row Security） <https://www.postgresql.org/docs/current/ddl-"
"rowsecurity.html>`_ 将被绕过，除非指定一个不同的、非超级用户（SUPERUSER）"
"所有者。"

#: ../../schema_structure.rst:83
msgid ""
"For changing this, we can create a non-SUPERUSER role and make this role "
"the view's owner."
msgstr ""
"为了改变这种情况，我们可以创建一个非超级用户（SUPERUSER）角色，并让这个角"
"色成为视图的所有者。"

#: ../../schema_structure.rst:91
msgid "Rules"
msgstr "规则"

#: ../../schema_structure.rst:93
msgid ""
"Insertion on views with complex `rules <https://www.postgresql.org/docs/"
"current/sql-createrule.html>`_ might not work out of the box with "
"PostgREST. It's recommended that you `use triggers instead of rules "
"<https://wiki.postgresql.org/wiki/Don%27t_Do_This#Don.27t_use_rules>`_. "
"If you want to keep using rules, a workaround is to wrap the view "
"insertion in a stored procedure and call it through the :ref:`s_procs` "
"interface. For more details, see this `github issue <https://github.com/"
"PostgREST/postgrest/issues/1283>`_."
msgstr ""
"复杂 `规则 <https://www.postgresql.org/docs/current/sql-createrule."
"html>`_ 的视图上的插入操作可能无法在 PostgREST 中正常工作。建议你 `使用触"
"发器而不是规则 <https://wiki.postgresql.org/wiki/Don"
"%27t_Do_This#Don.27t_use_rules>`_。如果你想继续使用规则，一个变通方法是把"
"视图插入语句包进存储过程，并通过 :ref:`s_procs` 接口调用它。更多细节，请"
"参见这个 `Github 问题 <https://github.com/PostgREST/postgrest/"
"issues/1283>`_。"
