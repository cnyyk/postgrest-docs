# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Joe Nelson, Steve Chavez
# This file is distributed under the same license as the PostgREST package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: PostgREST 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-13 08:59+0800\n"
"PO-Revision-Date: 2022-01-15 22:50+0800\n"
"Last-Translator: YCH <chnyyk@gmail.com>\n"
"Language: zh_CN\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../docs/api.rst:5
msgid "Tables and Views"
msgstr "表和视图"

#: ../../docs/api.rst:7
msgid ""
"All views and tables in the exposed schema and accessible by the active "
"database role for a request are available for querying. They are exposed "
"in one-level deep routes. For instance the full contents of a table "
"`people` is returned at"
msgstr ""
"公开暴露的 Schema "
"中的所有视图和表，以及当前请求的活动数据库角色可访问到的（视图和表），都可用于查询。它们被暴露在一级路由中。例如，以下请求将返回表 "
"`people` 的全部内容"

#: ../../docs/api.rst:19
msgid ""
"There are no deeply/nested/routes. Each route provides OPTIONS, GET, "
"HEAD, POST, PATCH, and DELETE verbs depending entirely on database "
"permissions."
msgstr ""
"不存在深度 / 嵌套的路由。每个路由都提供完全依赖于数据库权限的 OPTIONS、GET、HEAD、POST、PATCH 和 DELETE "
"动作（Verbs）。"

#: ../../docs/api.rst:23
msgid ""
"Why not provide nested routes? Many APIs allow nesting to retrieve "
"related information, such as :code:`/films/1/director`. We offer a more "
"flexible mechanism (inspired by GraphQL) to embed related information. It"
" can handle one-to-many and many-to-many relationships. This is covered "
"in the section about :ref:`resource_embedding`."
msgstr ""
"为何不提供嵌套路由？许多 API 允许嵌套检索相关信息，如 :code:`/films/1/director`。我们提供了一种更灵活的机制（受 "
"GraphQL 启发）来嵌入相关信息。它可以处理一对多和多对多的关系，将在 :ref:`resource_embedding` 一节中介绍。"

#: ../../docs/api.rst:28
msgid "Horizontal Filtering (Rows)"
msgstr "水平筛选（行）"

#: ../../docs/api.rst:30
msgid ""
"You can filter result rows by adding conditions on columns. For instance,"
" to return people aged under 13 years old:"
msgstr "你可以通过在列上添加条件来过滤结果行。例如，要返回年龄在 13 岁以下的人："

#: ../../docs/api.rst:42
msgid ""
"You can evaluate multiple conditions on columns by adding more query "
"string parameters. For instance, to return people who are 18 or older "
"**and** are students:"
msgstr "你可以通过添加更多的查询字符串参数来计算列上的多个条件。例如，要返回 18 岁及以上 **并且** 是学生的人："

#: ../../docs/api.rst:57
msgid "Operators"
msgstr "操作符"

#: ../../docs/api.rst:59
msgid "These operators are available:"
msgstr "可用操作符如下："

#: ../../docs/api.rst:62
msgid "Abbreviation"
msgstr "缩写"

#: ../../docs/api.rst:62
msgid "In PostgreSQL"
msgstr "PostgreSQL 操作符"

#: ../../docs/api.rst:62
msgid "Meaning"
msgstr "含义"

#: ../../docs/api.rst:64
msgid "eq"
msgstr "eq"

#: ../../docs/api.rst:64
msgid ":code:`=`"
msgstr ":code:`=`"

#: ../../docs/api.rst:64
msgid "equals"
msgstr "等于"

#: ../../docs/api.rst:65
msgid "gt"
msgstr "gt"

#: ../../docs/api.rst:65
msgid ":code:`>`"
msgstr ":code:`>`"

#: ../../docs/api.rst:65
msgid "greater than"
msgstr "大于"

#: ../../docs/api.rst:66
msgid "gte"
msgstr "gte"

#: ../../docs/api.rst:66
msgid ":code:`>=`"
msgstr ":code:`>=`"

#: ../../docs/api.rst:66
msgid "greater than or equal"
msgstr "大于等于"

#: ../../docs/api.rst:67
msgid "lt"
msgstr "lt"

#: ../../docs/api.rst:67
msgid ":code:`<`"
msgstr ":code:`<`"

#: ../../docs/api.rst:67
msgid "less than"
msgstr "小于"

#: ../../docs/api.rst:68
msgid "lte"
msgstr "let"

#: ../../docs/api.rst:68
msgid ":code:`<=`"
msgstr ":code:`<=`"

#: ../../docs/api.rst:68
msgid "less than or equal"
msgstr "小于等于"

#: ../../docs/api.rst:69
msgid "neq"
msgstr "neq"

#: ../../docs/api.rst:69
msgid ":code:`<>` or :code:`!=`"
msgstr ":code:`<>` 或 :code:`!=`"

#: ../../docs/api.rst:69
msgid "not equal"
msgstr "不等于"

#: ../../docs/api.rst:70
msgid "like"
msgstr "like"

#: ../../docs/api.rst:70
msgid ":code:`LIKE`"
msgstr ":code:`LIKE`"

#: ../../docs/api.rst:70
msgid "LIKE operator (use * in place of %)"
msgstr "LIKE 操作符（* 代替 %）"

#: ../../docs/api.rst:71
msgid "ilike"
msgstr "ilike"

#: ../../docs/api.rst:71
msgid ":code:`ILIKE`"
msgstr ":code:`ILIKE`"

#: ../../docs/api.rst:71
msgid "ILIKE operator (use * in place of %)"
msgstr "ILIKE 操作符（* 替代 %）"

#: ../../docs/api.rst:72
msgid "in"
msgstr "in"

#: ../../docs/api.rst:72
msgid ":code:`IN`"
msgstr ":code:`IN`"

#: ../../docs/api.rst:72
msgid ""
"one of a list of values, e.g. :code:`?a=in.(1,2,3)` – also supports "
"commas in quoted strings like :code:`?a=in.(\"hi,there\",\"yes,you\")`"
msgstr ""
"系列值中的一个，如 :code:`?a=in.(1,2,3)`。也支持引号字符串中的逗号，如 "
":code:`?a=in.(“hi,there”,”yes,you”)`"

#: ../../docs/api.rst:75
msgid "is"
msgstr "is"

#: ../../docs/api.rst:75
msgid ":code:`IS`"
msgstr ":code:`IS`"

#: ../../docs/api.rst:75
msgid "checking for exact equality (null,true,false,unknown)"
msgstr "检查是否完全相等（null / true / false / unknown）"

#: ../../docs/api.rst:76
msgid "fts"
msgstr "fts"

#: ../../docs/api.rst:76 ../../docs/api.rst:77 ../../docs/api.rst:78
#: ../../docs/api.rst:79
msgid ":code:`@@`"
msgstr ":code:`@@`"

#: ../../docs/api.rst:76
msgid ":ref:`fts` using to_tsquery"
msgstr ":ref:`fts` using to_tsquery"

#: ../../docs/api.rst:77
msgid "plfts"
msgstr "plfts"

#: ../../docs/api.rst:77
msgid ":ref:`fts` using plainto_tsquery"
msgstr ":ref:`fts` using plainto_tsquery"

#: ../../docs/api.rst:78
msgid "phfts"
msgstr "phfts"

#: ../../docs/api.rst:78
msgid ":ref:`fts` using phraseto_tsquery"
msgstr ":ref:`fts` using phraseto_tsquery"

#: ../../docs/api.rst:79
msgid "wfts"
msgstr "wfts"

#: ../../docs/api.rst:79
msgid ":ref:`fts` using websearch_to_tsquery"
msgstr ":ref:`fts` using websearch_to_tsquery"

#: ../../docs/api.rst:80
msgid "cs"
msgstr "cs"

#: ../../docs/api.rst:80
msgid ":code:`@>`"
msgstr ":code:`@>`"

#: ../../docs/api.rst:80
msgid "contains e.g. :code:`?tags=cs.{example, new}`"
msgstr "包含，如 :code:`?tags=cs.{example, new}`"

#: ../../docs/api.rst:81
msgid "cd"
msgstr "cd"

#: ../../docs/api.rst:81
msgid ":code:`<@`"
msgstr ":code:`<@`"

#: ../../docs/api.rst:81
msgid "contained in e.g. :code:`?values=cd.{1,2,3}`"
msgstr "包含于，如 :code:`?values=cd.{1,2,3}`"

#: ../../docs/api.rst:82
msgid "ov"
msgstr "ov"

#: ../../docs/api.rst:82
msgid ":code:`&&`"
msgstr ":code:`&&`"

#: ../../docs/api.rst:82
msgid ""
"overlap (have points in common), e.g. "
":code:`?period=ov.[2017-01-01,2017-06-30]` – also supports array types, "
"use curly braces instead of square brackets e.g. :code: `?arr=ov.{1,3}`"
msgstr ""
"重叠（有共同点），如 "
":code:`?period=ov.[2017-01-01,2017-06-30]`。也支持数组类型，使用大括号而不是方括号，如 :code: "
"`?arr=ov.{1,3}`"

#: ../../docs/api.rst:85
msgid "sl"
msgstr "sl"

#: ../../docs/api.rst:85
msgid ":code:`<<`"
msgstr ":code:`<<`"

#: ../../docs/api.rst:85
msgid "strictly left of, e.g. :code:`?range=sl.(1,10)`"
msgstr "严格意义上的左边，如 :code:`?range=sl.(1,10)`"

#: ../../docs/api.rst:86
msgid "sr"
msgstr "sr"

#: ../../docs/api.rst:86
msgid ":code:`>>`"
msgstr ":code:`>>`"

#: ../../docs/api.rst:86
msgid "strictly right of"
msgstr "严格意义上的右边"

#: ../../docs/api.rst:87
msgid "nxr"
msgstr "nxr"

#: ../../docs/api.rst:87
msgid ":code:`&<`"
msgstr ":code:`&<`"

#: ../../docs/api.rst:87
msgid "does not extend to the right of, e.g. :code:`?range=nxr.(1,10)`"
msgstr "不延伸到右边，如 :code:`?range=nxr. (1,10)`"

#: ../../docs/api.rst:88
msgid "nxl"
msgstr "nxl"

#: ../../docs/api.rst:88
msgid ":code:`&>`"
msgstr ":code:`&>`"

#: ../../docs/api.rst:88
msgid "does not extend to the left of"
msgstr "不延伸到左边"

#: ../../docs/api.rst:89
msgid "adj"
msgstr "adj"

#: ../../docs/api.rst:89
msgid ":code:`-|-`"
msgstr ":code:`-|-`"

#: ../../docs/api.rst:89
msgid "is adjacent to, e.g. :code:`?range=adj.(1,10)`"
msgstr "相邻的，如 :code:`?range=adj.(1,10)`"

#: ../../docs/api.rst:90
msgid "not"
msgstr "not"

#: ../../docs/api.rst:90
msgid ":code:`NOT`"
msgstr ":code:`NOT`"

#: ../../docs/api.rst:90
msgid "negates another operator, see :ref:`logical_operators`"
msgstr "对另一个操作符取反，参见 :ref:`logical_operators`"

#: ../../docs/api.rst:91
msgid "or"
msgstr "or"

#: ../../docs/api.rst:91
msgid ":code:`OR`"
msgstr ":code:`OR`"

#: ../../docs/api.rst:91
msgid "logical :code:`OR`, see :ref:`logical_operators`"
msgstr "逻辑的 :code:`OR`，参见 :ref:`logical_operators`"

#: ../../docs/api.rst:92
msgid "and"
msgstr "and"

#: ../../docs/api.rst:92
msgid ":code:`AND`"
msgstr ":code:`AND`"

#: ../../docs/api.rst:92
msgid "logical :code:`AND`, see :ref:`logical_operators`"
msgstr "逻辑的 :code:`AND`，参见 :ref:`logical_operators`"

#: ../../docs/api.rst:95
msgid ""
"For more complicated filters you will have to create a new view in the "
"database, or use a stored procedure. For instance, here's a view to show "
"\"today's stories\" including possibly older pinned stories:"
msgstr "对于更复杂的筛选，你必须在数据库中创建一个新的视图，或使用一个存储过程。例如，这里有一个显示“今天的故事”的视图，其中可能包括过去的被置顶的故事："

#: ../../docs/api.rst:106
msgid "The view will provide a new endpoint:"
msgstr "该视图将提供一个新的端点："

#: ../../docs/api.rst:121
msgid "Logical operators"
msgstr "逻辑运算符"

#: ../../docs/api.rst:123
msgid ""
"Multiple conditions on columns are evaluated using ``AND`` by default, "
"but you can combine them using ``OR`` with the ``or`` operator. For "
"example, to return people under 18 **or** over 21:"
msgstr ""
"列上的多个条件默认使用 ``AND`` 计算，但是你可以使用 ``OR`` 与 ``or`` 操作符来组合它们。例如，要返回 18 岁以下 "
"**或者** 21 岁以上的人："

#: ../../docs/api.rst:135
msgid ""
"To **negate** any operator, you can prefix it with :code:`not` like "
":code:`?a=not.eq.2` or :code:`?not.and=(a.gte.0,a.lte.100)` ."
msgstr ""
"要对任何运算符 **取反**，你可以在它前面加上 :code:`not`，如 :code:`?a=not.eq.2` 或 "
":code:`?not.and=(a.gte.0,a.lte.100)`。"

#: ../../docs/api.rst:137
msgid "You can also apply complex logic to the conditions:"
msgstr "你也可以将复杂的逻辑应用到这些条件上："

#: ../../docs/api.rst:152
msgid "Full-Text Search"
msgstr "全文检索"

#: ../../docs/api.rst:154
msgid ""
"The :code:`fts` filter mentioned above has a number of options to support"
" flexible textual queries, namely the choice of plain vs phrase search "
"and the language used for stemming. Suppose that :code:`tsearch` is a "
"table with column :code:`my_tsv`, of type `tsvector "
"<https://www.postgresql.org/docs/current/datatype-textsearch.html>`_. The"
" following examples illustrate the possibilities."
msgstr ""
"上面提到的 :code:`fts` 筛选有许多选项来支持灵活的文本查询，即普通搜索和短语搜索，以及用于词干分析的语言。假设 "
":code:`tsearch` 表包含类型为 `tsvector <https://www.postgresql.org/docs/current"
"/datatype-textsearch.html>`_ 的列 :code:`my_tsv`。下面的例子说明了这些可能性。"

#: ../../docs/api.rst:196
msgid ""
"Using `websearch_to_tsquery` requires PostgreSQL of version at least 11.0"
" and will raise an error in earlier versions of the database."
msgstr "使用 `websearch_to_tsquery` 需要至少 PostgreSQL 11，在更早版本上会报错。"

#: ../../docs/api.rst:201
msgid "Vertical Filtering (Columns)"
msgstr "垂直筛选（列）"

#: ../../docs/api.rst:203
msgid ""
"When certain columns are wide (such as those holding binary data), it is "
"more efficient for the server to withhold them in a response. The client "
"can specify which columns are required using the :sql:`select` parameter."
msgstr "当某些列很大时（比如那些保存二进制数据的列），服务器将其移除会让响应更高效。客户端可以使用 :sql:`select` 参数指定需要哪些列。"

#: ../../docs/api.rst:222
msgid ""
"The default is :sql:`*`, meaning all columns. This value will become more"
" important below in :ref:`resource_embedding`."
msgstr "默认是 :sql:`*`，表示所有列。这个值在下面的 :ref:`resource_embedding` 中会变得更加重要。"

#: ../../docs/api.rst:225
msgid "Renaming Columns"
msgstr "重命名列"

#: ../../docs/api.rst:227
msgid ""
"You can rename the columns by prefixing them with an alias followed by "
"the colon ``:`` operator."
msgstr "你可以通过在列名前加上别名和冒号 ``:`` 操作符来重命名这些列。"

#: ../../docs/api.rst:249
msgid "Casting Columns"
msgstr "列类型转换"

#: ../../docs/api.rst:251
msgid ""
"Casting the columns is possible by suffixing them with the double colon "
"``::`` plus the desired type."
msgstr "可通过给列名加上双冒号 ``::`` 及所需数据类型的后缀，来对列的类型进行转换。"

#: ../../docs/api.rst:273
msgid "Array / Composite / JSON Columns"
msgstr ""

#: ../../docs/api.rst:275
msgid ""
"You can specify a path for a ``json`` or ``jsonb`` column using the arrow"
" operators(``->`` or ``->>``) as per the `PostgreSQL docs "
"<https://www.postgresql.org/docs/current/functions-json.html>`_."
msgstr ""
"你可以使用箭头运算符（``->`` 或 ``->>``）为 ``json`` 或 ``jsonb`` 列指定路径，如同 `PostgreSQL "
"文档 <https://www.postgresql.org/docs/current/functions-json.html>`_ 一样。"

#: ../../docs/api.rst:318
msgid "This also works with filters:"
msgstr "也支持在筛选中使用："

#: ../../docs/api.rst:338
msgid ""
"Note that ``->>`` is used to compare ``blood_type`` as ``text``. To "
"compare with an integer value use ``->``:"
msgstr ""
"注意：``->>`` 将 ``blood_type`` 视为 ``text`` 比较。要与一个整数值（integer）进行比较，请使用 "
"``->``："

#: ../../docs/api.rst:358
msgid "The arrow operators are also used for array and composite type columns."
msgstr ""

#: ../../docs/api.rst:396
msgid ""
"When using the ``->`` and ``->>`` operators, PostgREST uses a query like "
"``to_jsonb(<col>)->'field'``. To make filtering and ordering on those "
"nested fields use an index, the index needs to be created on the same "
"expression, including the ``to_jsonb(...)`` call:"
msgstr ""

#: ../../docs/api.rst:405
#, fuzzy
msgid "Computed / Virtual Columns"
msgstr "计算列"

#: ../../docs/api.rst:407
msgid ""
"Filters may be applied to computed columns(**a.k.a. virtual columns**) as"
" well as actual table/view columns, even though the computed columns will"
" not appear in the output. For example, to search first and last names at"
" once we can create a computed column that will not appear in the output "
"but can be used in a filter:"
msgstr ""

#: ../../docs/api.rst:424
msgid "A full-text search on the computed column:"
msgstr ""

#: ../../docs/api.rst:436
msgid ""
"As mentioned, computed columns do not appear in the output by default. "
"However you can include them by listing them in the vertical filtering "
":code:`select` parameter:"
msgstr ""

#: ../../docs/api.rst:450
msgid ""
"Computed columns must be created in the :ref:`exposed schema <db-"
"schemas>` or in a schema in the :ref:`extra search path <db-extra-search-"
"path>` to be used in this way. When placing the computed column in the "
":ref:`exposed schema <db-schemas>` you can use an **unnamed** argument, "
"as in the example above, to prevent it from being exposed as an :ref:`RPC"
" <s_procs>` under ``/rpc``."
msgstr ""

#: ../../docs/api.rst:453
msgid "Unicode support"
msgstr "Unicode 支持"

#: ../../docs/api.rst:455
msgid ""
"PostgREST supports unicode in schemas, tables, columns and values. To "
"access a table with unicode name, use percent encoding."
msgstr ""

#: ../../docs/api.rst:457
msgid "To request this:"
msgstr ""

#: ../../docs/api.rst:463
msgid "Do this:"
msgstr ""

#: ../../docs/api.rst:478
msgid "Table / Columns with spaces"
msgstr "表名 / 列名包含空格"

#: ../../docs/api.rst:480
msgid ""
"You can request table/columns with spaces in them by percent encoding the"
" spaces with ``%20``:"
msgstr ""

#: ../../docs/api.rst:495
msgid "Reserved characters"
msgstr "保留字符"

#: ../../docs/api.rst:497
msgid ""
"If filters include PostgREST reserved characters(``,``, ``.``, ``:``, "
"``()``) you'll have to surround them in percent encoded double quotes "
"``%22`` for correct processing."
msgstr ""

#: ../../docs/api.rst:499
msgid "Here ``Hebdon,John`` and ``Williams,Mary`` are values."
msgstr ""

#: ../../docs/api.rst:511
msgid "Here ``information.cpe`` is a column name."
msgstr ""

#: ../../docs/api.rst:523
msgid ""
"If the value filtered by the ``in`` operator has a double quote (``\"``),"
" you can escape it using a backslash ``\"\\\"\"``. A backslash itself can"
" be used with a double backslash ``\"\\\\\"``."
msgstr ""

#: ../../docs/api.rst:525
msgid ""
"Here ``Quote:\"`` and ``Backslash:\\`` are percent-encoded values. Note "
"that ``%5C`` is the percent-encoded backslash."
msgstr ""

#: ../../docs/api.rst:539
msgid ""
"Some HTTP libraries might encode URLs automatically(e.g. :code:`axios`). "
"In these cases you should use double quotes :code:`\"\"` directly instead"
" of :code:`%22`."
msgstr ""

#: ../../docs/api.rst:543
msgid "Ordering"
msgstr "排序"

#: ../../docs/api.rst:545
msgid ""
"The reserved word :sql:`order` reorders the response rows. It uses a "
"comma-separated list of columns and directions:"
msgstr ""

#: ../../docs/api.rst:557
msgid "If no direction is specified it defaults to ascending order:"
msgstr ""

#: ../../docs/api.rst:569
msgid "If you care where nulls are sorted, add ``nullsfirst`` or ``nullslast``:"
msgstr ""

#: ../../docs/api.rst:591
msgid ""
"You can also use :ref:`computed_cols` to order the results, even though "
"the computed columns will not appear in the output. You can sort by "
"nested fields of :ref:`json_columns` with the JSON operators."
msgstr ""

#: ../../docs/api.rst:596
msgid "Limits and Pagination"
msgstr "结果限定和分页"

#: ../../docs/api.rst:598
msgid ""
"PostgREST uses HTTP range headers to describe the size of results. Every "
"response contains the current range and, if requested, the total number "
"of results:"
msgstr ""

#: ../../docs/api.rst:606
msgid ""
"Here items zero through fourteen are returned. This information is "
"available in every response and can help you render pagination controls "
"on the client. This is an RFC7233-compliant solution that keeps the "
"response JSON cleaner."
msgstr ""

#: ../../docs/api.rst:608
msgid ""
"There are two ways to apply a limit and offset rows: through request "
"headers or query parameters. When using headers you specify the range of "
"rows desired. This request gets the first twenty people."
msgstr ""

#: ../../docs/api.rst:624
msgid ""
"Note that the server may respond with fewer if unable to meet your "
"request:"
msgstr ""

#: ../../docs/api.rst:632
msgid ""
"You may also request open-ended ranges for an offset with no limit, e.g. "
":code:`Range: 10-`."
msgstr ""

#: ../../docs/api.rst:634
msgid ""
"The other way to request a limit or offset is with query parameters. For "
"example"
msgstr ""

#: ../../docs/api.rst:646
msgid ""
"This method is also useful for embedded resources, which we will cover in"
" another section. The server always responds with range headers even if "
"you use query parameters to limit the query."
msgstr ""

#: ../../docs/api.rst:651
msgid "Exact Count"
msgstr "精确统计"

#: ../../docs/api.rst:653
msgid ""
"In order to obtain the total size of the table or view (such as when "
"rendering the last page link in a pagination control), specify ``Prefer: "
"count=exact`` as a request header:"
msgstr ""

#: ../../docs/api.rst:671
msgid ""
"Note that the larger the table the slower this query runs in the "
"database. The server will respond with the selected range and total"
msgstr ""

#: ../../docs/api.rst:682
msgid "Planned Count"
msgstr "计划统计"

#: ../../docs/api.rst:684
msgid ""
"To avoid the shortcomings of :ref:`exact count <exact_count>`, PostgREST "
"can leverage PostgreSQL statistics and get a fairly accurate and fast "
"count. To do this, specify the ``Prefer: count=planned`` header."
msgstr ""

#: ../../docs/api.rst:704
msgid ""
"Note that the accuracy of this count depends on how up-to-date are the "
"PostgreSQL statistics tables. For example in this case, to increase the "
"accuracy of the count you can do ``ANALYZE bigtable``. See `ANALYZE "
"<https://www.postgresql.org/docs/current/sql-analyze.html>`_ for more "
"details."
msgstr ""

#: ../../docs/api.rst:711
msgid "Estimated Count"
msgstr "估算统计"

#: ../../docs/api.rst:713
msgid ""
"When you are interested in the count, the relative error is important. If"
" you have a :ref:`planned count <planned_count>` of 1000000 and the exact"
" count is 1001000, the error is small enough to be ignored. But with a "
"planned count of 7, an exact count of 28 would be a huge misprediction."
msgstr ""

#: ../../docs/api.rst:716
msgid ""
"In general, when having smaller row-counts, the estimated count should be"
" as close to the exact count as possible."
msgstr ""

#: ../../docs/api.rst:718
msgid ""
"To help with these cases, PostgREST can get the exact count up until a "
"threshold and get the planned count when that threshold is surpassed. To "
"use this behavior, you can specify the ``Prefer: count=estimated`` "
"header. The **threshold** is defined by :ref:`db-max-rows`."
msgstr ""

#: ../../docs/api.rst:722
msgid ""
"Here's an example. Suppose we set ``db-max-rows=1000`` and ``smalltable``"
" has 321 rows, then we'll get the exact count:"
msgstr ""

#: ../../docs/api.rst:741
msgid ""
"If we make a similar request on ``bigtable``, which has 3573458 rows, we "
"would get the planned count:"
msgstr ""

#: ../../docs/api.rst:763
msgid "Response Format"
msgstr "响应格式"

#: ../../docs/api.rst:765
msgid ""
"PostgREST uses proper HTTP content negotiation (`RFC7231 "
"<https://datatracker.ietf.org/doc/html/rfc7231#section-5.3>`_) to deliver"
" the desired representation of a resource. That is to say the same API "
"endpoint can respond in different formats like JSON or CSV depending on "
"the client request."
msgstr ""

#: ../../docs/api.rst:767
msgid ""
"Use the Accept request header to specify the acceptable format (or "
"formats) for the response:"
msgstr ""

#: ../../docs/api.rst:781
msgid "The current possibilities are:"
msgstr ""

#: ../../docs/api.rst:783
msgid "``*/*``"
msgstr ""

#: ../../docs/api.rst:784
msgid "``text/csv``"
msgstr ""

#: ../../docs/api.rst:785
msgid "``application/json``"
msgstr ""

#: ../../docs/api.rst:786
msgid "``application/openapi+json``"
msgstr ""

#: ../../docs/api.rst:787
msgid "``application/octet-stream``"
msgstr ""

#: ../../docs/api.rst:789
msgid "The server will default to JSON for API endpoints and OpenAPI on the root."
msgstr ""

#: ../../docs/api.rst:794
msgid "Singular or Plural"
msgstr "单数或复数"

#: ../../docs/api.rst:796
msgid ""
"By default PostgREST returns all JSON results in an array, even when "
"there is only one item. For example, requesting :code:`/items?id=eq.1` "
"returns"
msgstr ""

#: ../../docs/api.rst:804
msgid ""
"This can be inconvenient for client code. To return the first result as "
"an object unenclosed by an array, specify :code:`vnd.pgrst.object` as "
"part of the :code:`Accept` header"
msgstr ""

#: ../../docs/api.rst:818
msgid "This returns"
msgstr ""

#: ../../docs/api.rst:824
msgid ""
"When a singular response is requested but no entries are found, the "
"server responds with an error message and 406 Not Acceptable status code "
"rather than the usual empty array and 200 status:"
msgstr ""

#: ../../docs/api.rst:835
msgid ""
"Many APIs distinguish plural and singular resources using a special "
"nested URL convention e.g. `/stories` vs `/stories/1`. Why do we use "
"`/stories?id=eq.1`? The answer is because a singular resource is (for us)"
" a row determined by a primary key, and primary keys can be compound "
"(meaning defined across more than one column). The more familiar nested "
"urls consider only a degenerate case of simple and overwhelmingly numeric"
" primary keys. These so-called artificial keys are often introduced "
"automatically by Object Relational Mapping libraries."
msgstr ""

#: ../../docs/api.rst:837
msgid ""
"Admittedly PostgREST could detect when there is an equality condition "
"holding on all columns constituting the primary key and automatically "
"convert to singular. However this could lead to a surprising change of "
"format that breaks unwary client code just by filtering on an extra "
"column. Instead we allow manually specifying singular vs plural to "
"decouple that choice from the URL format."
msgstr ""

#: ../../docs/api.rst:842
msgid "Resource Embedding"
msgstr "资源嵌入"

#: ../../docs/api.rst:844
msgid ""
"In addition to providing RESTful routes for each table and view, "
"PostgREST allows related resources to be included together in a single "
"API call. This reduces the need for multiple API requests. The server "
"uses **foreign keys** to determine which tables and views can be returned"
" together. For example, consider a database of films and their awards:"
msgstr ""

#: ../../docs/api.rst:850
msgid ""
"PostgREST needs `FOREIGN KEY constraints "
"<https://www.postgresql.org/docs/current/tutorial-fk.html>`_ to be able "
"to do Resource Embedding."
msgstr ""

#: ../../docs/api.rst:854
msgid ""
"As seen above in :ref:`v_filter` we can request the titles of all films "
"like this:"
msgstr ""

#: ../../docs/api.rst:866
msgid "This might return something like"
msgstr ""

#: ../../docs/api.rst:876
msgid ""
"However because a foreign key constraint exists between Films and "
"Directors, we can request this information be included:"
msgstr ""

#: ../../docs/api.rst:888
msgid "Which would return"
msgstr ""

#: ../../docs/api.rst:913
msgid ""
"In this example, since the relationship is a forward relationship, there "
"is only one director associated with a film. As the table name is plural "
"it might be preferable for it to be singular instead. An table name alias"
" can accomplish this:"
msgstr ""

#: ../../docs/api.rst:930
msgid ""
"Whenever FOREIGN KEY constraints change in the database schema you must "
"refresh PostgREST's schema cache for Resource Embedding to work properly."
" See the section :ref:`schema_reloading`."
msgstr ""

#: ../../docs/api.rst:933
msgid "Embedding through join tables"
msgstr "通过连接表嵌入"

#: ../../docs/api.rst:935
msgid ""
"PostgREST can also detect relationships going through join tables. Thus "
"you can request the Actors for Films (which in this case finds the "
"information through Roles)."
msgstr ""

#: ../../docs/api.rst:950
msgid "Nested Embedding"
msgstr "多重嵌套"

#: ../../docs/api.rst:952
msgid ""
"If you want to embed through join tables but need more control on the "
"intermediate resources, you can do nested embedding. For instance, you "
"can request the Actors, their Roles and the Films for those Roles:"
msgstr ""

#: ../../docs/api.rst:967
msgid "Embedded Filters"
msgstr "嵌入过滤"

#: ../../docs/api.rst:969
msgid ""
"Embedded resources can be shaped similarly to their top-level "
"counterparts. To do so, prefix the query parameters with the name of the "
"embedded resource. For instance, to order the actors in each film:"
msgstr ""

#: ../../docs/api.rst:981
msgid ""
"This sorts the list of actors in each film but does *not* change the "
"order of the films themselves. To filter the roles returned with each "
"film:"
msgstr ""

#: ../../docs/api.rst:993
msgid ""
"Once again, this restricts the roles included to certain characters but "
"does not filter the films in any way. Films without any of those "
"characters would be included along with empty character lists."
msgstr ""

#: ../../docs/api.rst:995
msgid "An ``or`` filter  can be used for a similar operation:"
msgstr ""

#: ../../docs/api.rst:1007
msgid "Limit and offset operations are possible:"
msgstr ""

#: ../../docs/api.rst:1019
msgid ""
"Embedded resources can be aliased and filters can be applied on these "
"aliases:"
msgstr ""

#: ../../docs/api.rst:1031
msgid "Filters can also be applied on nested embedded resources:"
msgstr ""

#: ../../docs/api.rst:1043
msgid ""
"The result will show the nested actors named Tom and order them by last "
"name. Aliases can also be used instead of the resource names to filter "
"the nested tables."
msgstr ""

#: ../../docs/api.rst:1048
msgid "Embedding with Top-level Filtering"
msgstr "带有顶层筛选的嵌入"

#: ../../docs/api.rst:1050
msgid ""
"By default, :ref:`embed_filters` don't change the top-level "
"resource(``films``) rows at all:"
msgstr ""

#: ../../docs/api.rst:1084
msgid ""
"In order to filter the top level rows you need to add ``!inner`` to the "
"embedded resource. For instance, to get **only** the films that have an "
"actor named ``Jehanne``:"
msgstr ""

#: ../../docs/api.rst:1113
msgid "Embedding Partitioned Tables"
msgstr "嵌入分区表"

#: ../../docs/api.rst:1115
msgid ""
"Embedding can also be done between `partitioned tables "
"<https://www.postgresql.org/docs/current/ddl-partitioning.html>`_ and "
"other tables."
msgstr ""

#: ../../docs/api.rst:1117
msgid ""
"For example, let's create the ``box_office`` partitioned table that has "
"the gross daily revenue of a film:"
msgstr ""

#: ../../docs/api.rst:1138
msgid ""
"Since it contains the ``films_id`` foreign key, it is possible to embed "
"``box_office`` and ``films``:"
msgstr ""

#: ../../docs/api.rst:1151
msgid ""
"Embedding on partitions is not allowed because it leads to ambiguity "
"errors (see :ref:`embed_disamb`) between them and their parent "
"partitioned table(more details at `#1783(comment) "
"<https://github.com/PostgREST/postgrest/issues/1783#issuecomment-959823827>`_)."
" :ref:`custom_queries` can be used if this is needed."
msgstr ""

#: ../../docs/api.rst:1153
msgid ""
"Partitioned tables can reference other tables since PostgreSQL 11 but can"
" only be referenced from any other table since PostgreSQL 12."
msgstr ""

#: ../../docs/api.rst:1158
msgid "Embedding Views"
msgstr "嵌入视图"

#: ../../docs/api.rst:1160
msgid ""
"Embedding a view is possible if the view contains columns that have "
"**foreign keys** defined in their source tables."
msgstr ""

#: ../../docs/api.rst:1162
msgid ""
"As an example, let's create a view called ``nominations_view`` based on "
"the *nominations* table."
msgstr ""

#: ../../docs/api.rst:1174
msgid ""
"Since it contains ``competition_id`` and ``film_id`` — and each one has a"
" **foreign key** defined in its source table — we can embed "
"*competitions* and *films*:"
msgstr ""

#: ../../docs/api.rst:1186
msgid ""
"It's also possible to embed `Materialized Views "
"<https://www.postgresql.org/docs/current/rules-materializedviews.html>`_."
msgstr ""

#: ../../docs/api.rst:1190
msgid ""
"It's not guaranteed that all kinds of views will be embeddable. In "
"particular, views that contain UNIONs will not be made embeddable."
msgstr ""

#: ../../docs/api.rst:1193
msgid ""
"Why? PostgREST detects source table foreign keys in the view by querying "
"and parsing `pg_rewrite <https://www.postgresql.org/docs/current/catalog-"
"pg-rewrite.html>`_. This may fail depending on the complexity of the "
"view."
msgstr ""

#: ../../docs/api.rst:1196
msgid ""
"`Report an issue <https://github.com/PostgREST/postgrest/issues>`_ if "
"your view is not made embeddable so we can keep continue improving "
"foreign key detection."
msgstr ""

#: ../../docs/api.rst:1199
msgid ""
"In the future we'll include a way to manually specify views source "
"foreign keys to address this limitation."
msgstr ""

#: ../../docs/api.rst:1203
msgid ""
"If view definitions change you must refresh PostgREST's schema cache for "
"this to work properly. See the section :ref:`schema_reloading`."
msgstr ""

#: ../../docs/api.rst:1208
msgid "Embedding Chains of Views"
msgstr "嵌入视图链"

#: ../../docs/api.rst:1210
msgid ""
"Views can also depend on other views, which in turn depend on the actual "
"source table. For PostgREST to pick up those chains recursively to any "
"depth, all the views must be in the search path, so either in the exposed"
" schema (:ref:`db-schemas`) or in one of the schemas set in :ref:`db-"
"extra-search-path`. This does not apply to the source table, which could "
"be in a private schema as well. See :ref:`schema_isolation` for more "
"details."
msgstr ""

#: ../../docs/api.rst:1215
msgid "Embedding on Stored Procedures"
msgstr "嵌入存储过程"

#: ../../docs/api.rst:1217
msgid ""
"If you have a :ref:`Stored Procedure <s_procs>` that returns a table "
"type, you can embed its related resources."
msgstr ""

#: ../../docs/api.rst:1219
msgid "Here's a sample function (notice the ``RETURNS SETOF films``)."
msgstr ""

#: ../../docs/api.rst:1227
msgid "A request with ``directors`` embedded:"
msgstr ""

#: ../../docs/api.rst:1253
msgid "Embedding after Insertions/Updates/Deletions"
msgstr "插入 / 更新 / 删除后的嵌入"

#: ../../docs/api.rst:1255
msgid ""
"You can embed related resources after doing :ref:`insert_update` or "
":ref:`delete`."
msgstr ""

#: ../../docs/api.rst:1257
msgid ""
"Say you want to insert a **film** and then get some of its attributes "
"plus embed its **director**."
msgstr ""

#: ../../docs/api.rst:1290
msgid "Response:"
msgstr ""

#: ../../docs/api.rst:1306
msgid "Embedding Disambiguation"
msgstr "嵌入消除歧义"

#: ../../docs/api.rst:1308
msgid ""
"For doing resource embedding, PostgREST infers the relationship between "
"two tables based on a foreign key between them. However, in cases where "
"there's more than one foreign key between two tables, it's not possible "
"to infer the relationship unambiguously by just specifying the tables "
"names."
msgstr ""

#: ../../docs/api.rst:1315
msgid "Target Disambiguation"
msgstr ""

#: ../../docs/api.rst:1317
msgid ""
"For example, suppose you have the following ``orders`` and ``addresses`` "
"tables:"
msgstr ""

#: ../../docs/api.rst:1321
msgid ""
"And you try to embed ``orders`` with ``addresses`` (this is the "
"**target**):"
msgstr ""

#: ../../docs/api.rst:1333
msgid ""
"Since the ``orders`` table has two foreign keys to the ``addresses`` "
"table — an order has a billing address and a shipping address — the "
"request is ambiguous and PostgREST will respond with an error:"
msgstr ""

#: ../../docs/api.rst:1342
msgid ""
"If this happens, you need to disambiguate the request by adding precision"
" to the **target**. Instead of the **table name**, you can specify the "
"**foreign key constraint name** or the **column name** that is part of "
"the foreign key."
msgstr ""

#: ../../docs/api.rst:1345
msgid ""
"Let's try first with the **foreign key constraint name**. To make it "
"clearer we can name it:"
msgstr ""

#: ../../docs/api.rst:1358
msgid ""
"Now we can unambiguously embed the billing address by specifying the "
"``billing_address`` foreign key constraint as the **target**."
msgstr ""

#: ../../docs/api.rst:1381
msgid ""
"Alternatively, you can specify the **column name** of the foreign key "
"constraint as the **target**. This can be aliased to make the result more"
" clear."
msgstr ""

#: ../../docs/api.rst:1408
msgid "Hint Disambiguation"
msgstr ""

#: ../../docs/api.rst:1410
msgid ""
"If specifying the **target** is not enough for unambiguous embedding, you"
" can add a **hint**. For example, let's assume we create two views of "
"``addresses``: ``central_addresses`` and ``eastern_addresses``."
msgstr ""

#: ../../docs/api.rst:1413
msgid ""
"Since PostgREST supports :ref:`embedding_views` by detecting **source "
"foreign keys** in the views, embedding with the foreign key as the "
"**target** will not be enough for an unambiguous embed:"
msgstr ""

#: ../../docs/api.rst:1430
msgid ""
"For solving this case, in addition to the **target**, we can add a "
"**hint**. Here we specify ``central_addresses`` as the **target** and the"
" ``billing_address`` foreign key as the **hint**:"
msgstr ""

#: ../../docs/api.rst:1449
msgid ""
"Similarly to the **target**, the **hint** can be a **table name**, "
"**foreign key constraint name** or **column name**."
msgstr ""

#: ../../docs/api.rst:1451
msgid ""
"Hints also work alongside ``!inner`` if a top level filtering is needed. "
"From the above example:"
msgstr ""

#: ../../docs/api.rst:1466
msgid "Insertions / Updates"
msgstr "插入 / 更新"

#: ../../docs/api.rst:1468
msgid ""
"All tables and `auto-updatable views "
"<https://www.postgresql.org/docs/current/sql-createview.html#SQL-"
"CREATEVIEW-UPDATABLE-VIEWS>`_ can be modified through the API, subject to"
" permissions of the requester's database role."
msgstr ""

#: ../../docs/api.rst:1470
msgid ""
"To create a row in a database table post a JSON object whose keys are the"
" names of the columns you would like to create. Missing properties will "
"be set to default values when applicable."
msgstr ""

#: ../../docs/api.rst:1486
msgid ""
"If the table has a primary key, the response can contain a "
":code:`Location` header describing where to find the new object by "
"including the header :code:`Prefer: return=headers-only` in the request. "
"Make sure that the table is not write-only, otherwise constructing the "
":code:`Location` header will cause a permissions error."
msgstr ""

#: ../../docs/api.rst:1488
msgid ""
"On the other end of the spectrum you can get the full created object back"
" in the response to your request by including the header :code:`Prefer: "
"return=representation`. That way you won't have to make another HTTP call"
" to discover properties that may have been filled in on the server side. "
"You can also apply the standard :ref:`v_filter` to these results."
msgstr ""

#: ../../docs/api.rst:1490
msgid ""
"URL encoded payloads can be posted with ``Content-Type: application/x"
"-www-form-urlencoded``."
msgstr ""

#: ../../docs/api.rst:1509
msgid "When inserting a row you must post a JSON object, not quoted JSON."
msgstr ""

#: ../../docs/api.rst:1519
msgid ""
"Some JavaScript libraries will post the data incorrectly if you're not "
"careful. For best results try one of the :ref:`clientside_libraries` "
"built for PostgREST."
msgstr ""

#: ../../docs/api.rst:1521
msgid ""
"To update a row or rows in a table, use the PATCH verb. Use "
":ref:`h_filter` to specify which record(s) to update. Here is an example "
"query setting the :code:`category` column to child for all people below a"
" certain age."
msgstr ""

#: ../../docs/api.rst:1537
msgid ""
"Updates also support :code:`Prefer: return=representation` plus "
":ref:`v_filter`."
msgstr ""

#: ../../docs/api.rst:1541
msgid ""
"Beware of accidentally updating every row in a table. To learn to prevent"
" that see :ref:`block_fulltable`."
msgstr ""

#: ../../docs/api.rst:1546
msgid "Bulk Insert"
msgstr ""

#: ../../docs/api.rst:1548
msgid ""
"Bulk insert works exactly like single row insert except that you provide "
"either a JSON array of objects having uniform keys, or lines in CSV "
"format. This not only minimizes the HTTP requests required but uses a "
"single INSERT statement on the back-end for efficiency. Note that using "
"CSV requires less parsing on the server and is much faster."
msgstr ""

#: ../../docs/api.rst:1550
msgid ""
"To bulk insert CSV simply post to a table route with :code:`Content-Type:"
" text/csv` and include the names of the columns as the first row. For "
"instance"
msgstr ""

#: ../../docs/api.rst:1573
msgid ""
"An empty field (:code:`,,`) is coerced to an empty string and the "
"reserved word :code:`NULL` is mapped to the SQL null value. Note that "
"there should be no spaces between the column names and commas."
msgstr ""

#: ../../docs/api.rst:1575
msgid "To bulk insert JSON post an array of objects having all-matching keys"
msgstr ""

#: ../../docs/api.rst:1603
msgid "Specifying Columns"
msgstr ""

#: ../../docs/api.rst:1605
msgid ""
"By using the :code:`columns` query parameter it's possible to specify the"
" payload keys that will be inserted/updated and ignore the rest of the "
"payload."
msgstr ""

#: ../../docs/api.rst:1641
msgid ""
"In this case, only **source**, **publication_date** and **figure** will "
"be inserted. The rest of the JSON keys will be ignored."
msgstr ""

#: ../../docs/api.rst:1643
msgid ""
"Using this also has the side-effect of being more efficient for "
":ref:`bulk_insert` since PostgREST will not process the JSON and it'll "
"send it directly to PostgreSQL."
msgstr ""

#: ../../docs/api.rst:1649
msgid "UPSERT"
msgstr ""

#: ../../docs/api.rst:1651
msgid ""
"You can make an UPSERT with :code:`POST` and the :code:`Prefer: "
"resolution=merge-duplicates` header:"
msgstr ""

#: ../../docs/api.rst:1679
msgid ""
"By default, UPSERT operates based on the primary key columns, you must "
"specify all of them. You can also choose to ignore the duplicates with "
":code:`Prefer: resolution=ignore-duplicates`. This works best when the "
"primary key is natural, but it's also possible to use it if the primary "
"key is surrogate (example: \"id serial primary key\"). For more details "
"read `this issue <https://github.com/PostgREST/postgrest/issues/1118>`_."
msgstr ""

#: ../../docs/api.rst:1682
msgid ""
"After creating a table or changing its primary key, you must refresh "
"PostgREST schema cache for UPSERT to work properly. To learn how to "
"refresh the cache see :ref:`schema_reloading`."
msgstr ""

#: ../../docs/api.rst:1687
msgid "On Conflict"
msgstr ""

#: ../../docs/api.rst:1689
msgid ""
"By specifying the ``on_conflict`` query parameter, you can make UPSERT "
"work on a column(s) that has a UNIQUE constraint."
msgstr ""

#: ../../docs/api.rst:1718 ../../docs/api.rst:2426
msgid "PUT"
msgstr ""

#: ../../docs/api.rst:1720
msgid ""
"A single row UPSERT can be done by using :code:`PUT` and filtering the "
"primary key columns with :code:`eq`:"
msgstr ""

#: ../../docs/api.rst:1736
msgid ""
"All the columns must be specified in the request body, including the "
"primary key columns."
msgstr ""

#: ../../docs/api.rst:1741
msgid "Deletions"
msgstr "删除"

#: ../../docs/api.rst:1743
msgid ""
"To delete rows in a table, use the DELETE verb plus :ref:`h_filter`. For "
"instance deleting inactive users:"
msgstr ""

#: ../../docs/api.rst:1755
msgid ""
"Deletions also support :code:`Prefer: return=representation` plus "
":ref:`v_filter`."
msgstr ""

#: ../../docs/api.rst:1775
msgid ""
"Beware of accidentally deleting all rows in a table. To learn to prevent "
"that see :ref:`block_fulltable`."
msgstr ""

#: ../../docs/api.rst:1780
msgid "Custom Queries"
msgstr "自定义查询"

#: ../../docs/api.rst:1782
msgid ""
"The PostgREST URL grammar limits the kinds of queries clients can "
"perform. It prevents arbitrary, potentially poorly constructed and slow "
"client queries. It's good for quality of service, but means database "
"administrators must create custom views and stored procedures to provide "
"richer endpoints. The most common causes for custom endpoints are"
msgstr ""

#: ../../docs/api.rst:1784
msgid "Table unions"
msgstr ""

#: ../../docs/api.rst:1785
msgid "More complicated joins than those provided by `Resource Embedding`_"
msgstr ""

#: ../../docs/api.rst:1786
msgid ""
"Geo-spatial queries that require an argument, like \"points near "
"(lat,lon)\""
msgstr ""

#: ../../docs/api.rst:1791
msgid "Stored Procedures"
msgstr "存储过程"

#: ../../docs/api.rst:1793
msgid ""
"Every stored procedure in the API-exposed database schema is accessible "
"under the :code:`/rpc` prefix. The API endpoint supports POST (and in "
"some cases GET) to execute the function."
msgstr ""

#: ../../docs/api.rst:1805
msgid ""
"Such functions can perform any operations allowed by PostgreSQL (read "
"data, modify data, and even DDL operations)."
msgstr ""

#: ../../docs/api.rst:1807
msgid ""
"To supply arguments in an API call, include a JSON object in the request "
"payload and each key/value of the object will become an argument."
msgstr ""

#: ../../docs/api.rst:1809
msgid "For instance, assume we have created this function in the database."
msgstr ""

#: ../../docs/api.rst:1820
msgid ""
"Whenever you create or change a function you must refresh PostgREST's "
"schema cache. See the section :ref:`schema_reloading`."
msgstr ""

#: ../../docs/api.rst:1822
msgid "The client can call it by posting an object like"
msgstr ""

#: ../../docs/api.rst:1843
msgid ""
"Procedures must be declared with named parameters. Procedures declared "
"like"
msgstr ""

#: ../../docs/api.rst:1849
msgid ""
"cannot be called with PostgREST, since we use `named notation "
"<https://www.postgresql.org/docs/current/sql-syntax-calling-funcs.html"
"#SQL-SYNTAX-CALLING-FUNCS-NAMED>`_ internally."
msgstr ""

#: ../../docs/api.rst:1851
msgid ""
"Note that PostgreSQL converts identifier names to lowercase unless you "
"quote them like:"
msgstr ""

#: ../../docs/api.rst:1857
msgid ""
"PostgreSQL has four procedural languages that are part of the core "
"distribution: PL/pgSQL, PL/Tcl, PL/Perl, and PL/Python. There are many "
"other procedural languages distributed as additional extensions. Also, "
"plain SQL can be used to write functions (as shown in the example above)."
msgstr ""

#: ../../docs/api.rst:1861
msgid ""
"Why the ``/rpc`` prefix? One reason is to avoid name collisions between "
"views and procedures. It also helps emphasize to API consumers that these"
" functions are not normal restful things. The functions can have "
"arbitrary and surprising behavior, not the standard \"post creates a "
"resource\" thing that users expect from the other routes."
msgstr ""

#: ../../docs/api.rst:1864
msgid "Immutable and stable functions"
msgstr ""

#: ../../docs/api.rst:1866
msgid ""
"PostgREST executes POST requests in a read/write transaction except for "
"functions marked as ``IMMUTABLE`` or ``STABLE``. Those must not modify "
"the database and are executed in a read-only transaction compatible for "
"read-replicas."
msgstr ""

#: ../../docs/api.rst:1868
msgid ""
"Procedures that do not modify the database can be called with the HTTP "
"GET verb as well, if desired. PostgREST executes all GET requests in a "
"read-only transaction. Modifying the database inside read-only "
"transactions is not possible and calling volatile functions with GET will"
" fail."
msgstr ""

#: ../../docs/api.rst:1872
msgid ""
"The `volatility marker <https://www.postgresql.org/docs/current/xfunc-"
"volatility.html>`_ is a promise about the behavior of the function.  "
"PostgreSQL will let you mark a function that modifies the database as "
"``IMMUTABLE`` or ``STABLE`` without failure.  However, because of the "
"read-only transaction this would still fail with PostgREST."
msgstr ""

#: ../../docs/api.rst:1874
msgid ""
"Because ``add_them`` is ``IMMUTABLE``, we can alternately call the "
"function with a GET request:"
msgstr ""

#: ../../docs/api.rst:1886
msgid ""
"The function parameter names match the JSON object keys in the POST case,"
" for the GET case they match the query parameters ``?a=1&b=2``."
msgstr ""

#: ../../docs/api.rst:1891
msgid "Calling functions with a single JSON parameter"
msgstr ""

#: ../../docs/api.rst:1893
msgid ""
"You can also call a function that takes a single parameter of type JSON "
"by sending the header :code:`Prefer: params=single-object` with your "
"request. That way the JSON request body will be used as the single "
"argument."
msgstr ""

#: ../../docs/api.rst:1924
msgid "Calling functions with a single unnamed parameter"
msgstr "调用单个未命名参数的函数"

#: ../../docs/api.rst:1926
msgid ""
"You can make a POST request to a function with a single unnamed parameter"
" to send raw ``json/jsonb``, ``bytea`` or ``text`` data."
msgstr ""

#: ../../docs/api.rst:1928
msgid ""
"To send raw JSON, the function must have a single unnamed ``json`` or "
"``jsonb`` parameter and the header ``Content-Type: application/json`` "
"must be included in the request."
msgstr ""

#: ../../docs/api.rst:1957
msgid ""
"If an overloaded function has a single ``json`` or ``jsonb`` unnamed "
"parameter, PostgREST will call this function as a fallback provided that "
"no other overloaded function is found with the parameters sent in the "
"POST request."
msgstr ""

#: ../../docs/api.rst:1959
msgid ""
"To send raw binary, the parameter type must be ``bytea`` and the header "
"``Content-Type: application/octet-stream`` must be included in the "
"request."
msgstr ""

#: ../../docs/api.rst:1990
msgid ""
"To send raw text, the parameter type must be ``text`` and the header "
"``Content-Type: text/plain`` must be included in the request."
msgstr ""

#: ../../docs/api.rst:1995
msgid "Calling functions with array parameters"
msgstr ""

#: ../../docs/api.rst:1997
msgid "You can call a function that takes an array parameter:"
msgstr ""

#: ../../docs/api.rst:2024
msgid ""
"For calling the function with GET, you can pass the array as an `array "
"literal <https://www.postgresql.org/docs/current/arrays.html#ARRAYS-"
"INPUT>`_, as in ``{1,2,3,4}``. Note that the curly brackets have to be "
"urlencoded(``{`` is ``%7B`` and ``}`` is ``%7D``)."
msgstr ""

#: ../../docs/api.rst:2039
msgid ""
"For versions prior to PostgreSQL 10, to pass a PostgreSQL native array on"
" a POST payload, you need to quote it and use an array literal:"
msgstr ""

#: ../../docs/api.rst:2055
msgid ""
"In these versions we recommend using function parameters of type JSON to "
"accept arrays from the client."
msgstr ""

#: ../../docs/api.rst:2060
msgid "Calling variadic functions"
msgstr ""

#: ../../docs/api.rst:2062
msgid ""
"You can call a variadic function by passing a JSON array in a POST "
"request:"
msgstr ""

#: ../../docs/api.rst:2089
msgid "In a GET request, you can repeat the same parameter name:"
msgstr ""

#: ../../docs/api.rst:2101
msgid ""
"Repeating also works in POST requests with ``Content-Type: application/x"
"-www-form-urlencoded``:"
msgstr ""

#: ../../docs/api.rst:2119
msgid "Scalar functions"
msgstr ""

#: ../../docs/api.rst:2121
msgid ""
"PostgREST will detect if the function is scalar or table-valued and will "
"shape the response format accordingly:"
msgstr ""

#: ../../docs/api.rst:2158
msgid "Bulk Call"
msgstr ""

#: ../../docs/api.rst:2160
msgid ""
"It's possible to call a function in a bulk way, analogously to "
":ref:`bulk_insert`. To do this, you need to add the ``Prefer: params"
"=multiple-objects`` header to your request."
msgstr ""

#: ../../docs/api.rst:2190
msgid ""
"If you have large payloads to process, it's preferable you instead use a "
"function with an :ref:`array parameter <s_procs_array>` or JSON "
"parameter, as this will be more efficient."
msgstr ""

#: ../../docs/api.rst:2192
msgid ""
"It's also possible to :ref:`Specify Columns <specify_columns>` on "
"functions calls."
msgstr ""

#: ../../docs/api.rst:2195
msgid "Function filters"
msgstr ""

#: ../../docs/api.rst:2197
msgid ""
"A function that returns a table type response can be shaped using the "
"same filters as the ones used for tables and views:"
msgstr ""

#: ../../docs/api.rst:2224
msgid "Overloaded functions"
msgstr ""

#: ../../docs/api.rst:2226
msgid "You can call overloaded functions with different number of arguments."
msgstr ""

#: ../../docs/api.rst:2256
msgid ""
"Overloaded functions with the same argument names but different types are"
" not supported."
msgstr ""

#: ../../docs/api.rst:2261
msgid "Binary Output"
msgstr "二进制输出"

#: ../../docs/api.rst:2263
msgid ""
"If you want to return raw binary data from a :code:`bytea` column, you "
"must specify :code:`application/octet-stream` as part of the "
":code:`Accept` header and select a single column "
":code:`?select=bin_data`."
msgstr ""

#: ../../docs/api.rst:2278
msgid ""
"You can also request binary output when calling `Stored Procedures`_ and "
"since they can return a scalar value you are not forced to use "
":code:`select` for this case."
msgstr ""

#: ../../docs/api.rst:2297
msgid ""
"If the stored procedure returns non-scalar values, you need to do a "
":code:`select` in the same way as for GET binary output."
msgstr ""

#: ../../docs/api.rst:2317
msgid ""
"If more than one row would be returned the binary results will be "
"concatenated with no delimiter."
msgstr ""

#: ../../docs/api.rst:2322
msgid "Plain Text Output"
msgstr ""

#: ../../docs/api.rst:2324
msgid ""
"You can get raw output from a ``text`` column by using ``Accept: "
"text/plain``."
msgstr ""

#: ../../docs/api.rst:2345
msgid "This follows the same rules as :ref:`binary_output`."
msgstr ""

#: ../../docs/api.rst:2350
msgid "OpenAPI Support"
msgstr "OpenAPI 支持"

#: ../../docs/api.rst:2352
msgid ""
"Every API hosted by PostgREST automatically serves a full `OpenAPI "
"<https://www.openapis.org/>`_ description on the root path. This provides"
" a list of all endpoints (tables, foreign tables, views, functions), "
"along with supported HTTP verbs and example payloads."
msgstr ""

#: ../../docs/api.rst:2356
msgid ""
"By default, this output depends on the permissions of the role that is "
"contained in the JWT role claim (or the :ref:`db-anon-role` if no JWT is "
"sent). If you need to show all the endpoints disregarding the role's "
"permissions, set the :ref:`openapi-mode` config to :code:`ignore-"
"privileges`."
msgstr ""

#: ../../docs/api.rst:2358
msgid ""
"For extra customization, the OpenAPI output contains a \"description\" "
"field for every `SQL comment <https://www.postgresql.org/docs/current"
"/sql-comment.html>`_ on any database object. For instance,"
msgstr ""

#: ../../docs/api.rst:2371
msgid ""
"These unsavory comments will appear in the generated JSON as the fields, "
"``info.description``, ``definitions.monotremes.description`` and "
"``definitions.monotremes.properties.has_venomous_claw.description``."
msgstr ""

#: ../../docs/api.rst:2373
msgid ""
"Also if you wish to generate a ``summary`` field you can do it by having "
"a multiple line comment, the ``summary`` will be the first line and the "
"``description`` the lines that follow it:"
msgstr ""

#: ../../docs/api.rst:2384
msgid ""
"You can use a tool like `Swagger UI <https://swagger.io/tools/swagger-"
"ui/>`_ to create beautiful documentation from the description and to host"
" an interactive web-based dashboard. The dashboard allows developers to "
"make requests against a live PostgREST server, and provides guidance with"
" request headers and example request bodies."
msgstr ""

#: ../../docs/api.rst:2388
msgid ""
"The OpenAPI information can go out of date as the schema changes under a "
"running server. To learn how to refresh the cache see "
":ref:`schema_reloading`."
msgstr ""

#: ../../docs/api.rst:2393
msgid "OPTIONS"
msgstr "OPTIONS 方法"

#: ../../docs/api.rst:2395
msgid ""
"You can verify which HTTP methods are allowed on endpoints for tables and"
" views by using an OPTIONS request. These methods are allowed depending "
"on what operations *can* be done on the table or view, not on the "
"database permissions assigned to them."
msgstr ""

#: ../../docs/api.rst:2397
msgid "For a table named ``people``, OPTIONS would show:"
msgstr ""

#: ../../docs/api.rst:2414
msgid ""
"For a view, the methods are determined by the presence of INSTEAD OF "
"TRIGGERS."
msgstr ""

#: ../../docs/api.rst:2420
msgid "Method allowed"
msgstr ""

#: ../../docs/api.rst:2420
msgid "View's requirements"
msgstr ""

#: ../../docs/api.rst:2422
msgid "OPTIONS, GET, HEAD"
msgstr ""

#: ../../docs/api.rst:2422
msgid "None (Always allowed)"
msgstr ""

#: ../../docs/api.rst:2424
msgid "POST"
msgstr ""

#: ../../docs/api.rst:2424
msgid "INSTEAD OF INSERT TRIGGER"
msgstr ""

#: ../../docs/api.rst:2426
msgid ""
"INSTEAD OF INSERT TRIGGER, INSTEAD OF UPDATE TRIGGER, also requires the "
"presence of a primary key"
msgstr ""

#: ../../docs/api.rst:2429
msgid "PATCH"
msgstr ""

#: ../../docs/api.rst:2429
msgid "INSTEAD OF UPDATE TRIGGER"
msgstr ""

#: ../../docs/api.rst:2431
msgid "DELETE"
msgstr ""

#: ../../docs/api.rst:2431
msgid "INSTEAD OF DELETE TRIGGER"
msgstr ""

#: ../../docs/api.rst:2433
msgid ""
"All the above methods are allowed for `auto-updatable views "
"<https://www.postgresql.org/docs/current/sql-createview.html#SQL-"
"CREATEVIEW-UPDATABLE-VIEWS>`_"
msgstr ""

#: ../../docs/api.rst:2437
msgid "For functions, OPTIONS requests are not supported."
msgstr ""

#: ../../docs/api.rst:2441
msgid ""
"Whenever you add or remove tables or views, or modify a view's INSTEAD OF"
" TRIGGERS on the database, you must refresh PostgREST's schema cache for "
"OPTIONS requests to work properly. See the section "
":ref:`schema_reloading`."
msgstr ""

#: ../../docs/api.rst:2444
msgid "CORS"
msgstr ""

#: ../../docs/api.rst:2446
msgid ""
"PostgREST sets highly permissive cross origin resource sharing, that is "
"why it accepts Ajax requests from any domain."
msgstr ""

#: ../../docs/api.rst:2451
msgid "Switching Schemas"
msgstr "切换 Schema"

#: ../../docs/api.rst:2453
msgid ""
"You can switch schemas at runtime with the ``Accept-Profile`` and "
"``Content-Profile`` headers. You can only switch to a schema that is "
"included in :ref:`db-schemas`."
msgstr ""

#: ../../docs/api.rst:2455
msgid ""
"For GET or HEAD, the schema to be used can be selected through the "
"``Accept-Profile`` header:"
msgstr ""

#: ../../docs/api.rst:2469
msgid ""
"For POST, PATCH, PUT and DELETE, you can use the ``Content-Profile`` "
"header for selecting the schema:"
msgstr ""

#: ../../docs/api.rst:2487
msgid "You can also select the schema for :ref:`s_procs` and :ref:`open-api`."
msgstr ""

#: ../../docs/api.rst:2491
msgid ""
"These headers are based on the nascent \"Content Negotiation by Profile\""
" spec: https://www.w3.org/TR/dx-prof-conneg"
msgstr ""

#: ../../docs/api.rst:2496
msgid "HTTP Context"
msgstr "HTTP 上下文"

#: ../../docs/api.rst:2501
msgid "Accessing Request Headers, Cookies and JWT claims"
msgstr ""

#: ../../docs/api.rst:2503
msgid ""
"You can access request headers, cookies and JWT claims by reading GUC "
"variables set by PostgREST per request. They are named "
":code:`request.headers`, :code:`request.cookies` and "
":code:`request.jwt.claims`."
msgstr ""

#: ../../docs/api.rst:2521
msgid ""
"The ``role`` in ``request.jwt.claims`` defaults to the value of :ref:`db-"
"anon-role`."
msgstr ""

#: ../../docs/api.rst:2526
msgid "Legacy GUC variable names"
msgstr "老的 GUC 变量名称"

#: ../../docs/api.rst:2528
msgid ""
"For PostgreSQL versions below 14, PostgREST will take into consideration "
"the :ref:`db-use-legacy-gucs` config, which is set to true by default. "
"This means that the interface for accessing these GUCs is `the same as in"
" older versions <https://postgrest.org/en/v8.0/api.html#accessing-"
"request-headers-cookies-and-jwt-claims>`_. You can opt in to use the JSON"
" GUCs mentioned above by setting the ``db-use-legacy-gucs`` to false."
msgstr ""

#: ../../docs/api.rst:2533
msgid "Accessing Request Path and Method"
msgstr ""

#: ../../docs/api.rst:2535
msgid ""
"You can also access the request path and method with :code:`request.path`"
" and :code:`request.method`."
msgstr ""

#: ../../docs/api.rst:2548
msgid "Setting Response Headers"
msgstr ""

#: ../../docs/api.rst:2550
msgid ""
"PostgREST reads the ``response.headers`` SQL variable to add extra "
"headers to the HTTP response. Stored procedures can modify this variable."
" For instance, this statement would add caching headers to the response:"
msgstr ""

#: ../../docs/api.rst:2559
msgid ""
"Notice that the variable should be set to an *array* of single-key "
"objects rather than a single multiple-key object. This is because headers"
" such as ``Cache-Control`` or ``Set-Cookie`` need to be repeated when "
"setting multiple values and an object would not allow the repeated key."
msgstr ""

#: ../../docs/api.rst:2563
msgid ""
"PostgREST provided headers such as ``Content-Type``, ``Location``, etc. "
"can be overriden this way. Note that irrespective of overridden "
"``Content-Type`` response header, the content will still be converted to "
"JSON, unless you also set :ref:`raw-media-types` to something like "
"``text/html``."
msgstr ""

#: ../../docs/api.rst:2568
msgid "Setting headers via pre-request"
msgstr ""

#: ../../docs/api.rst:2570
msgid ""
"By using a :ref:`db-pre-request` function, you can add headers to "
"GET/POST/PATCH/PUT/DELETE responses. As an example, let's add some cache "
"headers for all requests that come from an Internet Explorer(6 or 7) "
"browser."
msgstr ""

#: ../../docs/api.rst:2588
msgid ""
"Now when you make a GET request to a table or view, you'll get the cache "
"headers."
msgstr ""

#: ../../docs/api.rst:2611
msgid "Setting Response Status Code"
msgstr ""

#: ../../docs/api.rst:2613
msgid ""
"You can set the ``response.status`` GUC to override the default status "
"code PostgREST provides. For instance, the following function would "
"replace the default ``200`` status code."
msgstr ""

#: ../../docs/api.rst:2642
msgid ""
"If the status code is standard, PostgREST will complete the status "
"message(**I'm a teapot** in this example)."
msgstr ""

#: ../../docs/api.rst:2647
msgid "Raise errors with HTTP Status Codes"
msgstr ""

#: ../../docs/api.rst:2649
msgid ""
"Stored procedures can return non-200 HTTP status codes by raising SQL "
"exceptions. For instance, here's a saucy function that always responds "
"with an error:"
msgstr ""

#: ../../docs/api.rst:2663
msgid "Calling the function returns HTTP 400 with the body"
msgstr ""

#: ../../docs/api.rst:2676
msgid ""
"Keep in mind that ``RAISE EXCEPTION`` will abort the transaction and "
"rollback all changes. If you don't want this, you can instead use the "
":ref:`response.status GUC <guc_resp_status>`."
msgstr ""

#: ../../docs/api.rst:2678
msgid ""
"One way to customize the HTTP status code is by raising particular "
"exceptions according to the PostgREST :ref:`error to status code mapping "
"<status_codes>`. For example, :code:`RAISE insufficient_privilege` will "
"respond with HTTP 401/403 as appropriate."
msgstr ""

#: ../../docs/api.rst:2680
msgid ""
"For even greater control of the HTTP status code, raise an exception of "
"the ``PTxyz`` type. For instance to respond with HTTP 402, raise 'PT402':"
msgstr ""

#: ../../docs/api.rst:2689
msgid "Returns:"
msgstr ""

#: ../../docs/api.rst:2701
msgid "HTTP Status Codes"
msgstr ""

#: ../../docs/api.rst:2703
msgid ""
"PostgREST translates `PostgreSQL error codes "
"<https://www.postgresql.org/docs/current/errcodes-appendix.html>`_ into "
"HTTP status as follows:"
msgstr ""

#: ../../docs/api.rst:2706
msgid "PostgreSQL error code(s)"
msgstr ""

#: ../../docs/api.rst:2706
msgid "HTTP status"
msgstr ""

#: ../../docs/api.rst:2706
msgid "Error description"
msgstr ""

#: ../../docs/api.rst:2708
msgid "08*"
msgstr ""

#: ../../docs/api.rst:2708 ../../docs/api.rst:2736
msgid "503"
msgstr ""

#: ../../docs/api.rst:2708
msgid "pg connection err"
msgstr ""

#: ../../docs/api.rst:2710
msgid "09*"
msgstr ""

#: ../../docs/api.rst:2710 ../../docs/api.rst:2722 ../../docs/api.rst:2726
#: ../../docs/api.rst:2728 ../../docs/api.rst:2730 ../../docs/api.rst:2732
#: ../../docs/api.rst:2734 ../../docs/api.rst:2740 ../../docs/api.rst:2742
#: ../../docs/api.rst:2744 ../../docs/api.rst:2746 ../../docs/api.rst:2748
#: ../../docs/api.rst:2752 ../../docs/api.rst:2754
msgid "500"
msgstr ""

#: ../../docs/api.rst:2710
msgid "triggered action exception"
msgstr ""

#: ../../docs/api.rst:2712
msgid "0L*"
msgstr ""

#: ../../docs/api.rst:2712 ../../docs/api.rst:2714 ../../docs/api.rst:2724
msgid "403"
msgstr ""

#: ../../docs/api.rst:2712
msgid "invalid grantor"
msgstr ""

#: ../../docs/api.rst:2714
msgid "0P*"
msgstr ""

#: ../../docs/api.rst:2714
msgid "invalid role specification"
msgstr ""

#: ../../docs/api.rst:2716
msgid "23503"
msgstr ""

#: ../../docs/api.rst:2716 ../../docs/api.rst:2718
msgid "409"
msgstr ""

#: ../../docs/api.rst:2716
msgid "foreign key violation"
msgstr ""

#: ../../docs/api.rst:2718
msgid "23505"
msgstr ""

#: ../../docs/api.rst:2718
msgid "uniqueness violation"
msgstr ""

#: ../../docs/api.rst:2720
msgid "25006"
msgstr ""

#: ../../docs/api.rst:2720
msgid "405"
msgstr ""

#: ../../docs/api.rst:2720
msgid "read only sql transaction"
msgstr ""

#: ../../docs/api.rst:2722
msgid "25*"
msgstr ""

#: ../../docs/api.rst:2722
msgid "invalid transaction state"
msgstr ""

#: ../../docs/api.rst:2724
msgid "28*"
msgstr ""

#: ../../docs/api.rst:2724
msgid "invalid auth specification"
msgstr ""

#: ../../docs/api.rst:2726
msgid "2D*"
msgstr ""

#: ../../docs/api.rst:2726
msgid "invalid transaction termination"
msgstr ""

#: ../../docs/api.rst:2728
msgid "38*"
msgstr ""

#: ../../docs/api.rst:2728
msgid "external routine exception"
msgstr ""

#: ../../docs/api.rst:2730
msgid "39*"
msgstr ""

#: ../../docs/api.rst:2730
msgid "external routine invocation"
msgstr ""

#: ../../docs/api.rst:2732
msgid "3B*"
msgstr ""

#: ../../docs/api.rst:2732
msgid "savepoint exception"
msgstr ""

#: ../../docs/api.rst:2734
msgid "40*"
msgstr ""

#: ../../docs/api.rst:2734
msgid "transaction rollback"
msgstr ""

#: ../../docs/api.rst:2736
msgid "53*"
msgstr ""

#: ../../docs/api.rst:2736
msgid "insufficient resources"
msgstr ""

#: ../../docs/api.rst:2738
msgid "54*"
msgstr ""

#: ../../docs/api.rst:2738
msgid "413"
msgstr ""

#: ../../docs/api.rst:2738
msgid "too complex"
msgstr ""

#: ../../docs/api.rst:2740
msgid "55*"
msgstr ""

#: ../../docs/api.rst:2740
msgid "obj not in prerequisite state"
msgstr ""

#: ../../docs/api.rst:2742
msgid "57*"
msgstr ""

#: ../../docs/api.rst:2742
msgid "operator intervention"
msgstr ""

#: ../../docs/api.rst:2744
msgid "58*"
msgstr ""

#: ../../docs/api.rst:2744
msgid "system error"
msgstr ""

#: ../../docs/api.rst:2746
msgid "F0*"
msgstr ""

#: ../../docs/api.rst:2746
msgid "config file error"
msgstr ""

#: ../../docs/api.rst:2748
msgid "HV*"
msgstr ""

#: ../../docs/api.rst:2748
msgid "foreign data wrapper error"
msgstr ""

#: ../../docs/api.rst:2750
msgid "P0001"
msgstr ""

#: ../../docs/api.rst:2750 ../../docs/api.rst:2763
msgid "400"
msgstr ""

#: ../../docs/api.rst:2750
msgid "default code for \"raise\""
msgstr ""

#: ../../docs/api.rst:2752
msgid "P0*"
msgstr ""

#: ../../docs/api.rst:2752
msgid "PL/pgSQL error"
msgstr ""

#: ../../docs/api.rst:2754
msgid "XX*"
msgstr ""

#: ../../docs/api.rst:2754
msgid "internal error"
msgstr ""

#: ../../docs/api.rst:2756
msgid "42883"
msgstr ""

#: ../../docs/api.rst:2756 ../../docs/api.rst:2758
msgid "404"
msgstr ""

#: ../../docs/api.rst:2756
msgid "undefined function"
msgstr ""

#: ../../docs/api.rst:2758
msgid "42P01"
msgstr ""

#: ../../docs/api.rst:2758
msgid "undefined table"
msgstr ""

#: ../../docs/api.rst:2760
msgid "42501"
msgstr ""

#: ../../docs/api.rst
msgid "if authenticated 403,"
msgstr ""

#: ../../docs/api.rst
msgid "else 401"
msgstr ""

#: ../../docs/api.rst:2760
msgid "insufficient privileges"
msgstr ""

#: ../../docs/api.rst:2763
msgid "other"
msgstr ""

#~ msgid "JSON Columns"
#~ msgstr "JSON 列"

#~ msgid ""
#~ "Computed columns must be created under"
#~ " the :ref:`exposed schema <db-schemas>` "
#~ "to be used in this way."
#~ msgstr ""

#~ msgid ""
#~ "You can also use :ref:`computed_cols` to"
#~ " order the results, even though the"
#~ " computed columns will not appear in"
#~ " the output."
#~ msgstr ""

#~ msgid ""
#~ "PostgREST provided headers such as "
#~ "``Content-Type``, ``Location``, etc. can be"
#~ " overriden this way."
#~ msgstr ""

