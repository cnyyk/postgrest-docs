# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Joe Nelson, Steve Chavez
# This file is distributed under the same license as the PostgREST package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: PostgREST 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-10 20:06+0800\n"
"PO-Revision-Date: 2022-01-17 20:15+0800\n"
"Last-Translator: YCH <chnyyk@gmail.com>\n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"X-Generator: Poedit 3.0.1\n"

#: ../../how-tos/casting-type-to-custom-json.rst:2
msgid "Casting a type to a custom JSON object"
msgstr "将类型转换为自定义 JSON 对象"

#: ../../how-tos/casting-type-to-custom-json.rst
#: ../../how-tos/embedding-table-from-another-schema.rst
#: ../../how-tos/providing-images-for-img.rst
msgid "author"
msgstr "作者"

#: ../../how-tos/casting-type-to-custom-json.rst:4
#: ../../how-tos/embedding-table-from-another-schema.rst:4
msgid "`steve-chavez <https://github.com/steve-chavez>`_"
msgstr "`steve-chavez <https://github.com/steve-chavez>`_"

#: ../../how-tos/casting-type-to-custom-json.rst:6
msgid ""
"While using PostgREST you might have noticed that certain PostgreSQL types "
"translate to JSON strings when you would have expected a JSON object or "
"array. For example, let's see the case of `range types <https://www."
"postgresql.org/docs/current/rangetypes.html>`_."
msgstr ""
"在使用 PostgREST 时，你可能会注意到某些 PostgreSQL 类型会转换成 JSON 字符串，"
"而你原本期望的是 JSON 对象或数组。让我们以 `范围类型 <https://www.postgresql."
"org/docs/current/rangetypes.html>`_ 为例，来看看这种情况。"

#: ../../how-tos/casting-type-to-custom-json.rst:22
msgid ""
"Here we have a column named **during** as a ``tsrange`` type, we would like "
"to get it as JSON through PostgREST."
msgstr ""
"这里我们有一个 ``tsrange`` 类型的列 **during**，我们想通过 PostgREST 获得它的 "
"JSON 格式。"

#: ../../how-tos/casting-type-to-custom-json.rst:28
msgid "Result:"
msgstr "结果："

#: ../../how-tos/casting-type-to-custom-json.rst:39
msgid ""
"The **during** value is probably not the in the format you want. We get a "
"JSON string because by default PostgreSQL casts the type to JSON by using its "
"``text`` representation. We can change this representation to a custom JSON "
"object by `creating a CAST <https://www.postgresql.org/docs/current/sql-"
"createcast.html>`_ ."
msgstr ""
"**during** 的值可能不是你想要的格式。我们得到了一个 JSON 字符串，因为默认情况"
"下，PostgreSQL 将其 ``text`` 形态转换为 JSON。我们可以通过 `创建类型转换"
"（CREATE CAST） <https://www.postgresql.org/docs/current/sql-createcast."
"html>`_ 来将这个形态改变为一个自定义的 JSON 对象。"

#: ../../how-tos/casting-type-to-custom-json.rst:42
msgid ""
"To do this, first we'll define the function that will do the conversion from "
"``tsrange`` to ``json``."
msgstr "要做到这一点，首先我们要定义一个函数将 ``tsrange`` 转换为 ``json``。"

#: ../../how-tos/casting-type-to-custom-json.rst:55
msgid "Using this function we'll create the CAST."
msgstr "我们使用该函数来创建类型转换（CREATE CAST）。"

#: ../../how-tos/casting-type-to-custom-json.rst:61
msgid "And we'll do the request and :ref:`cast the column <casting_columns>`."
msgstr "我们将进行请求，并 :ref:`转换列类型 <casting_columns>`。"

#: ../../how-tos/casting-type-to-custom-json.rst:67
msgid "The result now is:"
msgstr "现在的结果是："

#: ../../how-tos/casting-type-to-custom-json.rst:83
msgid "You can use the same idea for creating custom casts for different types."
msgstr "你可以使用相同的想法为类型创建自定义转换。"

#: ../../how-tos/casting-type-to-custom-json.rst:87
msgid ""
"If you don't want to modify casts for built-in types, an option would be to "
"`create a custom type <https://www.postgresql.org/docs/current/sql-createtype."
"html>`_ for your own ``tsrange`` and add its own cast."
msgstr ""
"如果你不想修改内置类型的转换，可能的选项是为你自己的 ``tsrange`` 类型和它的转"
"换 `创建自定义类型 <https://www.postgresql.org/docs/current/sql-createtype."
"html>`_。"

#: ../../how-tos/embedding-table-from-another-schema.rst:2
msgid "Embedding a table from another schema"
msgstr "嵌入其他 Schema 的表"

#: ../../how-tos/embedding-table-from-another-schema.rst:6
msgid ""
"Suppose you have a **people** table in the ``public`` schema and this schema "
"is exposed through PostgREST's :ref:`db-schemas`."
msgstr ""
"假设你在 ``public`` Schema 中有一个 **people** 表，这个 Schema 是通过 "
"PostgREST 的 :ref:`db-schemas` 暴露的。"

#: ../../how-tos/embedding-table-from-another-schema.rst:15
msgid ""
"And you want to :ref:`embed <resource_embedding>` the **people** table with a "
"**details** table that's in another schema named ``private``."
msgstr ""
"然后你想在 **people** 表 :ref:`嵌入 <resource_embedding>` 与另一个 `private` "
"Schema 里的 **details** 表。"

#: ../../how-tos/embedding-table-from-another-schema.rst:35
msgid ""
"To solve this, you can create a view of **details** in the ``public`` schema. "
"We'll call it **public_details**."
msgstr ""
"要解决此问题，你可以在 ``public`` Schema 里创建一个 **details** 视图。我们就叫"
"它 **public_details** 吧。"

#: ../../how-tos/embedding-table-from-another-schema.rst:47
msgid ""
"Since PostgREST supports :ref:`embedding_views`, you can embed **people** "
"with **public_details**."
msgstr ""
"由于 PostgREST 支持 :ref:`embedding_views`，你可以将 **public_details** 嵌入 "
"**people**。"

#: ../../how-tos/embedding-table-from-another-schema.rst:49
msgid "Let's insert some data to test this:"
msgstr "让我们插入一些数据来测试一下："

#: ../../how-tos/embedding-table-from-another-schema.rst:66
msgid ""
"Make sure PostgREST's schema cache is up-to-date. See :ref:`schema_reloading`."
msgstr "请确保 PostgREST 的 Schema 缓存是最新的。参见 :ref:`schema_reloading`。"

#: ../../how-tos/embedding-table-from-another-schema.rst:68
msgid "Now, make the following request:"
msgstr "现在，发出以下请求："

#: ../../how-tos/embedding-table-from-another-schema.rst:74
msgid "The result should be:"
msgstr "结果应该是："

#: ../../how-tos/providing-images-for-img.rst:4
msgid "Providing images for ``<img>``"
msgstr "图像转 ``<img>``"

#: ../../how-tos/providing-images-for-img.rst:6
msgid "`pkel <https://github.com/pkel>`_"
msgstr "`pkel <https://github.com/pkel>`_"

#: ../../how-tos/providing-images-for-img.rst:8
msgid ""
"In this how-to, you will learn how to create an endpoint for providing images "
"to HTML :code:`<img>` tags without client side JavaScript. The resulting HTML "
"might look like this:"
msgstr ""
"在本示例中，你将学习如何创建一个端点，无需客户端 JavaScript 就能提供 HTML :"
"code:`<img>` 标签和图像。由此产生的 HTML 可能是这样的："

#: ../../how-tos/providing-images-for-img.rst:15
msgid ""
"In fact, the presented technique is suitable for providing not only images, "
"but arbitrary files."
msgstr "事实上，该方法不仅适用于生成图像，还适用于生成任意类型文件。"

#: ../../how-tos/providing-images-for-img.rst:17
msgid ""
"We will start with a minimal example that highlights the general concept. "
"Afterwards we present are more detailed solution that fixes a few "
"shortcomings of the first approach."
msgstr ""
"我们将从一个突出基本概念的最小示例开始。之后，我们将介绍更详细的解决方案，该解"
"决方案修复了第一种方法的一些缺点。"

#: ../../how-tos/providing-images-for-img.rst:21
msgid "Minimal Example"
msgstr "最小示例"

#: ../../how-tos/providing-images-for-img.rst:23
msgid ""
"PostgREST returns binary data on requests that set the :code:`Accept: "
"application/octet-stream` header. The general idea is to configure the "
"reverse proxy in front of the API to set this header for all requests to :"
"code:`/files/`. We will show how to achieve this using Nginx."
msgstr ""
"PostgREST 对设置了 :code:`Accept: application/octet-stream` 消息头的请求返回二"
"进制数据。一般做法是，在 API 前面配置反向代理，为所有请求设置这个头，即 :code:"
"`/files/`。我们将展示如何使用 Nginx 来实现这一点。"

#: ../../how-tos/providing-images-for-img.rst:27
msgid "First, we need a public table for storing the files."
msgstr "首先，我们需要创建一个可被公开访问的表来存储文件。"

#: ../../how-tos/providing-images-for-img.rst:36
msgid ""
"Let's assume this table contains an image of two cute kittens with id 42. We "
"can retrieve this image in binary format from our PostgREST API by "
"requesting :code:`/files?select=blob&id=eq.42` with the :code:`Accept: "
"application/octet-stream` header. Unfortunately, putting the URL into the :"
"code:`src` of an :code:`<img>` tag will not work. That's because browsers do "
"not send the required header."
msgstr ""
"假设这个表包含 id 为 42 的两只可爱小猫的图片。我们可用带有 :code:`Accept: "
"application/octet-stream` 消息头的请求 :code:`/files?select=blob&id=eq.42`，"
"从 PostgREST API 中取出二进制格式的图像。不幸的是，将该请求 URL 放到 :code:"
"`src` 标签上是行不通的，这是因为浏览器并不发送所需的消息头。"

#: ../../how-tos/providing-images-for-img.rst:41
msgid ""
"Luckily, we can configure our :ref:`Nginx reverse proxy <admin>` to fix this "
"problem for us. We assume that PostgREST is running on port 3000. We provide "
"a new location :code:`/files/` that redirects requests to our endpoint with "
"the :code:`Accept` header set to :code:`application/octet-stream`."
msgstr ""
"幸运的是，我们可以配置 :ref:`Nginx 反向代理 <admin>` 来解决这个问题。假设 "
"PostgREST 运行在 3000 端口。我们将提供一个新的位置 :code:`/files/`，它会带着值"
"为 :code:`application/octet-stream` 的 :code:`Accept` 消息头将请求重定向到前述"
"端点。"

#: ../../how-tos/providing-images-for-img.rst:66
msgid ""
"With this setup, we can request the cat image at :code:`localhost/files/42/"
"cats.jpeg` without setting any headers. In fact, you can replace :code:`cats."
"jpeg` with any other filename or simply omit it. Putting the URL into the :"
"code:`src` of an :code:`<img>` tag should now work as expected."
msgstr ""
"通过这个设置，我们可以访问 :code:`localhost/files/42/cats.jpeg` 去获取猫的图"
"像，而不需要设置任何消息头。事实上，你可以用任何其他文件名替换 URL 结尾的 :"
"code:`cats.jpeg` 或者直接省略它。然后将这个 URL 放入 :code:`<img>` 标签的 :"
"code:`src`，现在应该可以正常工作啦。"

#: ../../how-tos/providing-images-for-img.rst:71
msgid "Improved Version"
msgstr "改良版本"

#: ../../how-tos/providing-images-for-img.rst:73
msgid "The basic solution has some shortcomings:"
msgstr "前面这个基础的解决方案尚有一些不足之处："

#: ../../how-tos/providing-images-for-img.rst:75
msgid ""
"The response :code:`Content-Type` header is set to :code:`application/octet-"
"stream`. This might confuse clients and users."
msgstr ""
"响应的 :code:`Content-Type` 消息头被设置为 :code:`application/octet-stream`。"
"这可能让客户端和用户发懵。"

#: ../../how-tos/providing-images-for-img.rst:77
msgid ""
"Download requests (e.g. Right Click -> Save Image As) to :code:`files/42` "
"will propose :code:`42` as filename. This might confuse users."
msgstr ""
"下载（如：右键 -> 图片另存为） :code:`files/42` 时默认文件名是 :code:`42`。这"
"也可能会让用户迷糊。"

#: ../../how-tos/providing-images-for-img.rst:79
msgid ""
"Requests to the binary endpoint are not cached. This will cause unnecessary "
"load on the database."
msgstr "对二进制端点的请求不会被缓存，会给数据库增加不必要的负担。"

#: ../../how-tos/providing-images-for-img.rst:82
msgid ""
"The following improved version addresses these problems. First, we store the "
"media types and names of our files in the database."
msgstr ""
"下面的改进版解决了这些问题。首先，我们将文件的媒体类型和名称存储到数据库中。"

#: ../../how-tos/providing-images-for-img.rst:94
msgid ""
"Next, we set up an RPC endpoint that sets the content type and filename. We "
"use this opportunity to configure some basic, client-side caching. For "
"production, you probably want to configure additional caches, e.g. on the "
"reverse proxy."
msgstr ""
"接下来，我们设置一个配置了内容类型和文件名的 RPC 端点，也顺带配置了基本的客户"
"端缓存。对于生产环境，你可能还需要配置额外的缓存，例如在反向代理上。"

#: ../../how-tos/providing-images-for-img.rst:123
msgid ""
"With this, we can obtain the cat image from :code:`/rpc/file?id=42`. "
"Consequently, we have to replace our previous rewrite rule in the Nginx "
"recipe with the following."
msgstr ""
"有了这个，我们就可以从 :code:`/rpc/file?id=42` 获取猫的图片。因此，我们须将 "
"Nginx 配置中以前的重写规则替换为以下内容。"
